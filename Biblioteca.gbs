--  JCFS Biblioteca
procedure PonerN(veces, color){
/* Proposito:: Colocar "veces" bolitas de color "color" en la celda actual. */
  repeat(veces){
		Poner(color);
	}
}

procedure PonerNAl(color, numero, dir){
	/* Pone "numero" bolitas de color "color" en la celda lindante en direccion "dir" dejando el cabezal en la celda actual */
	Mover(dir)
	repeat(numero){
		Poner(color)
	}
	Mover(opuesto(dir))
}

procedure PonerSi(color, b){
/* Dado un color "color" y un booleano b, pone una bolita de color c en la celda actual si b es True, y no hace nada si este es False.*/
	if (b){
		Poner(color)
	}
}

procedure SacarN(color, veces){
/* Proposito:: Saca "veces" bolitas de color "color" en la celda actual. 
   Precondicion: Debe haber "veces" bolitas color "color" en la celda actual */
  repeat(veces){
		Sacar(color);
	}
}

procedure SacarSi(color, condicion){
	/* Saca una bolita de color "color" si se cumple la condicion "condicion".
	Debe haber una bolita de color "color". */
	if (condicion){
		Sacar(color)
	}
}

procedure MoverN(direccion, numero){
	/* Mueve el cabezal "numero" celdas al "direccion". 
   Deben haber "numero" celdas en direccion "direccion" */
	repeat(numero){
		Mover(direccion)
	}
}

procedure MoverSi(direccion, condicion){
	/* Mueve el cabezal si se cumple la condicion "condicion" */
	if (condicion){
		Mover(direccion)
	}
}

procedure SacarTodas(color){
	/* Saca todas las bolitas de color "color" de la celda actual */
	SacarN(color, nroBolitas(color))	
}

procedure LineaNAl(color, numero, direccion){
	repeat(numero){
		Mover(direccion)
		Poner(color)
	}
}	

procedure CopiarBolitasCAl(color, dir){
/* Proposito: copia las bolitas de color "color" a la celda lindante en direccion "dir". El cabezal queda en la celda actual */  
	repeat(nroBolitas(color)){
		Mover(dir)
		Poner(color)
		Mover(opuesto(dir))
	}
}

/* Proposito: Copia las bolitas de la celda actual a la lindante en direccion "dir" 
 Precondicion: Una celda en direccion "dir" */
procedure CopiarCeldaAl(dir){
	foreach color in [minColor()..maxColor()]{
		PonerNAl(color, dir, nroBolitas(color))
	}
}


/* Quita "deg" cantidad de bolitas de color "c" si hay mas de "deg" de bolitas de color "c",  si no saca todas las de este color */
procedure DegradarCelda(deg, c){
	if (nroBolitas(c) > deg){
		SacarN(c, deg)
	} else {
		SacarTodas(c)
	}
}


/* Chequea si la celda actual esta vacia, es decir de ningun color. retorna True si lo esta*/
function vacia(){
	return (not ( hayBolitas(Azul) || hayBolitas(Negro) || hayBolitas(Rojo) || hayBolitas(Verde) ) )
}

/* Mueve el cabezal hasta la primer celda color c desde la celda actual hasta el borde en direccion d. Si No encuentra celda con el color c y el cabezal queda en la celda mas al "d" de la fila o columna*/
procedure IrHastaColor(c, d){
	while ( puedeMover(d) && not hayBolitas(c)){
		Mover(d)
	}
}

/* Lleva el cabezal al extremo de la fila (Este u Oeste) o columna (Sur o Norte) */
procedure IrAlExtremo(d){
	while ( puedeMover(d) ) {
		Mover(d)
	}
}

/* Recibe dos direcciones d1 y d2 y mueve el cabezal al inicio del recorrido. En otras palabras, el cabezal se mueve al extremo opuesto(d1) + opuesto(d2) */
procedure IrAlInicioT(d1, d2){
	IrAlExtremo(opuesto(d1))
	IrAlExtremo(opuesto(d2))
}

function puedeMoverT(d1, d2){
	return ( puedeMover(d1) || puedeMover(d2) )
}

/* Precondicion: debe haber una celda en direccion d2 o d1 */
procedure MoverT(d1, d2){
	if (puedeMover(d1)){
		Mover(d1)
	}else{
		IrAlExtremo(opuesto(d1))
		Mover(d2)
	}
}
/* retorna el valor en valueTrue si se cumple la condicion bool como verdadra, en caso contrario devuelve el valor en valueFalse */
function ifElse(bool, valueTrue, valueFalse
){
	value := valueFalse
	if (bool){
		value := valueTrue
	}
	return (value)
}

procedure IrANesimaVacia(n){
	/* Mueve el cabezal hasta la n esima celda vacia del tablero respecto a la celda inicial (Sur-Oeste) y recorriendo el tablero en direccion Noret Este, si no la encuentra queda en la ultima */ 
	vacias_vistas := 0
	IrAlInicioT(Norte, Este)
	vacias_vistas := ifElse(vacia(), vacias_vistas + 1, vacias_vistas)
	while ( puedeMoverT(Norte, Este) && n /= vacias_vistas ){
		MoverT(Norte,Este)
		vacias_vistas := ifElse(vacia(), vacias_vistas + 1, vacias_vistas)
	}
}

function menor(v1, v2){
	/* proposito: denota el menor valor entre v1 y v2.
	precond: v1 y v2 deben denotar el mismo tipo de valores 
	param: v1 y v2 valores a comparar. */
	menor := v1
	if (v1 > v2){
		menor := v2
	}
	return (menor)
}

function mayor(v1, v2){
	/* proposito: denota el mayor valor entre v1 y v2.
	precond: v1 y v2 deben denotar el mismo tipo de valores 
	param: v1 y v2 valores a comparar. */
	mayor := v1
	if (v1 < v2){
		mayor := v2
	}
	return (mayor)
}

